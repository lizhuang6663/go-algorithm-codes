package main

// 位运算（不是太理解）
// 力扣：https://leetcode.cn/problems/add-without-plus-lcci/
// 题解：https://leetcode.cn/problems/add-without-plus-lcci/solutions/806769/java-wei-yun-suan-chao-100si-lu-qing-xi-g1h59/
// 相同题目：https://leetcode.cn/problems/sum-of-two-integers/

// 为什么要 &  << 1 ^ 呢？
// 借助十进制加法199+2来理解
// 不进位的结果 191 进位的结果 10，需要继续把191和10加起来得到最终结果
// 191+10 不进位的结果 101 进位的结果 100
// 101+100 不进位的结果 201 进位的结果 0
// 最终结果就是201

func add(a int, b int) int {
	for b != 0 {
		// 使用位与运算 (a & b) 来计算进位。a & b 会返回 a 和 b 中所有对应二进制位都为 1 的位，与之对应的运算规则是：当两位相加都是 1 时，结果位 1 在下一位向前进位。因此，这里计算出需要进位的位。
		// 然后，使用左移运算符 << 1 将进位值向左移动一位，因为进位是在下一位有效的。
		// 例如，如果 a = 12 (1100), b = 10 (1010)，则 a & b 的结果是 1000。进位值 carry 将被计算为 1000 << 1，即 10000（16 的二进制）。
		carry := uint(a&b) << 1 // 进位

		// 使用异或运算符 ^ 来计算不带进位的和。在二进制中，异或运算符将 1 ^ 1 和 0 ^ 0 结果为 0，而 1 ^ 0 和 0 ^ 1 结果为 1。
		// 这意味着对于每一位，只有在两位之一为 1 时，结果为 1，否则结果为 0。用这个方法获取当前的和。
		a ^= b // 相加
		b = int(carry)
	}
	return a
}

// 假设 a = 5（二进制为 0101）和 b = 3（二进制为 0011）：
// 第一次循环:
// 计算 carry:
// a & b = 0101 & 0011 = 0001（表示需要进位）
// carry = 0001 << 1 = 0010（将该进位提升到下一个位置）
// 计算新的 a:
// a = a ^ b = 0101 ^ 0011 = 0110（现在是 6）
// 更新 b 为进位 carry = 0010（2）

// 第二次循环:
// 计算 carry:
// a & b = 0110 & 0010 = 0010（需要进位）
// carry = 0010 << 1 = 0100（将进位提升）
// 计算新的 a:
// a = a ^ b = 0110 ^ 0010 = 0100（现在是 4）
// 更新 b 为 carry = 0100（4）

// 第三次循环:
// 计算 carry:
// a & b = 0100 & 0100 = 0100（需要进位）
// carry = 0100 << 1 = 1000（将进位提升）
// 计算新的 a:
// a = a ^ b = 0100 ^ 0100 = 0000（现在是 0）
// 更新 b 为 carry = 1000（8）

// 第四次循环:
// 计算 carry:
// a & b = 0000 & 1000 = 0000（没有需要的进位）
// carry = 0000 << 1 = 0000
// 计算新的 a:
// a = a ^ b = 0000 ^ 1000 = 1000（现在是 8，最终结果）
// 更新 b 为 carry = 0000。
// 结束条件: b 为 0，返回 a，即 8。

// 递归，原理和上面相同
// func add(a int, b int) int {
// 	if b == 0 {
// 		return a
// 	}
// 	return add(a^b, int(uint(a&b)<<1))
// }
